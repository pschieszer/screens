<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.0" style="background-color: black">
	<script>
		const defaultState = {
			sizeX: 0,
			sizeY: 0,
			spread: 75,
			symX: true,
			symY: true,
			pointCount: 1200,
			pointAttr: { color: 0 },
			delay: 5000,
			frameCount: 6,
			displayMode: "dots",
			pointSource: "rorschach"
		};

		const getRand = (x) => Math.floor(Math.random() * x);

		const getOffset = (state) => {
			let theta = getRand(360);
			let radius = getRand(state.spread);
			return ({x: (radius * Math.cos(theta)), y: (radius * Math.sin(theta))});
		};

		const isOdd = (value, whenOdd = true, whenEven = false) => Math.floor(value % 2) == 1 ? whenOdd : whenEven;

		const rorschach = function* (state) {
			let currX = state.startX;
			let currY = state.startY;
			// yield up to four points on each iteration
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				if (state.symX)
					yield ({x: (state.sizeX - currX), y: currY, id: `pnt${pntNdx}symX`, ...state.pointAttr});
				if (state.symY)
					yield ({x: currX, y: (state.sizeY - currY), id: `pnt${pntNdx}symY`, ...state.pointAttr});
				if (state.symX && state.symY)
					yield ({x: (state.sizeX - currX), y: (state.sizeY - currY), id: `pnt${pntNdx}bothSym`, ...state.pointAttr});
				let mover = getOffset(state);
				currX += mover.x;
				currY += mover.y;
				if (pntNdx % 17 == 3) {
					// let the symmetry settings randomly change every 17 iterations
					//  because it increases the randomness of the output
					state.symY = isOdd(currY);
					state.symX = isOdd(currX);
				}
			}
		};

		const sinus = function* (state) {
			const zeroX = state.startX;
			const zeroY = state.startY;
			const nearY = Math.min((state.sizeY - zeroY), zeroY);
			const farX = Math.max((state.sizeX - zeroX), zeroX);
			const amplitude = nearY / 2;
			const sign = (farX === zeroX) ? -1 : 1;
			const incX = sign * farX / Number(state.pointCount);
			const trig = isOdd(zeroX, Math.sin, Math.cos);
			const freq = Math.sqrt(farX);
			let theta = 0;
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				yield ({
					x: zeroX + theta,
					y: (amplitude * trig(sign * theta / freq)) + zeroY,
					id: `pnt${pntNdx}`,
					 ...state.pointAttr
				});
				theta += incX;
			}
		};

		const tangent = function* (state) {
			let currX = state.startX;
			let currY = state.startY;
			const amplitude = (state.sizeX - currX) / 60;
			const farX = Math.max((state.sizeX - currX), currX);
			const sign = (farX === currX) ? -1 : 1;
			const freq = Math.sqrt(farX);
			const zeroX = currX;
			const zeroY = currY;
			const incX = sign * farX / Number(state.pointCount);
			let theta = 0;
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				currY = (amplitude * Math.tan(theta)) + zeroY;
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				theta += (sign * incX / freq);
			}
		};

		const sawtooth = function* (state) {
			let currX = state.startX;
			let currY = state.startY;
			let diff = 0;
			const nearY = Math.min((state.sizeY - currY), currY);
			const amplitude = nearY / 2;
			const zeroX = currX;
			const zeroY = currY;
			const incX = ((state.sizeX - zeroX) / Number(state.pointCount));
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				diff = currX - zeroX;
				currY = (amplitude * (diff - Math.floor(diff))) + zeroY;
			}
		};

		const fourier = (x, n) => (4 * Math.sin(n * x)) / (Math.PI * n);

		const square = function* (state) {
			let currX = state.startX;
			let currY = state.startY;
			const nearY = Math.min((state.sizeY - currY), currY);
			const farX = Math.max((state.sizeX - currX), currX);
			const sign = (farX === currX) ? -1 : 1;
			const freq = Math.sqrt(farX);
			const amplitude = nearY / 2;
			const zeroY = currY;
			const incX = sign * farX / Number(state.pointCount);
			let theta = 0;
			const coefficients = [1, 3, 5, 7, 9, 11];
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				let norm = coefficients.reduce((acc, curr) => acc + fourier(theta, curr), 0);
				currY = (amplitude * norm) + zeroY;
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				theta += (sign * incX / freq);
			}
		};

		const randomSource = function* (state) {
			yield* SourceLookup[getRand(SourceLookup.length)][1](state);
		};

		const SourceLookup = [["rorschach", rorschach], ["sinus", sinus], ["tangent", tangent],
			 ["sawtooth", sawtooth], ["square", square], ["random", randomSource]];

		const getPointSource = ({ pointSource }) => {
			const foundSource = SourceLookup.filter(x => x[0] === pointSource).map(x => x[1]).shift();
			return (foundSource) ? foundSource : rorschach;
		};


		const generatePoints = function* (state) {
			yield* getPointSource(state)(state);
		};

		const drawDot = ({x, y, id, color}) => {
			const result = document.createElementNS("http://www.w3.org/2000/svg", "circle");
			result.setAttribute("id", id);
			result.setAttribute("cx", `${x}`);
			result.setAttribute("cy", `${y}`);
			result.setAttribute("r", `1`);
			const currCol = `hsl(${color} 100% 50%)`;
			result.setAttribute("fill", currCol);
			result.setAttribute("stroke", currCol);
			return result;
		};

		// continguous blocks of code points that have a bunch of emojis to choose from
		const EmojiBox = [[0x2600, 0x26FF], [0x2700, 0x27BF], [0x1F600, 0x1F6D5],
			 [0x1F300, 0x1F53D], [0x1F700, 0x1F773], [0x1F900, 0x1F9FF]];

		const getEmojiCodePoint = () => {
			const [min, max] = EmojiBox[getRand(EmojiBox.length)];
			return getRand(max - min) + min;
		}

		const selectEmoji = () => String.fromCodePoint(getEmojiCodePoint());

		const drawEmoji = ({x, y, id, color}) => {
			const result = document.createElementNS("http://www.w3.org/2000/svg", "text");
			result.setAttributeNS(null, "x", x);
			result.setAttributeNS(null, "y", y);
			result.setAttribute("id", id);
			const currCol = `hsl(${color} 100% 50%)`;
			result.setAttribute("fill", currCol);
			result.setAttribute("stroke", currCol);
			result.appendChild(document.createTextNode(selectEmoji()));
			return result;
		};

		const buildParms = new URLSearchParams(window.location.search);
		const requestable = ['displayMode', 'pointCount', 'delay', 'frameCount', 'spread', 'pointSource', 'height', 'width'];

		const getParam = (attrib) => {
			const requested = buildParms.get(attrib);
			return (requested) ? requested : defaultState[attrib];
		}

		const getHeight = () => {
			const reqHeight = getParam('height');
			return (reqHeight) ? Number(reqHeight) : window.innerHeight * .98;
		}

		const getWidth = () => {
			const reqWidth = getParam('width');
			return (reqWidth) ? Number(reqWidth) : window.innerWidth * .98;
		}

		const getState = () => {
			const result = JSON.parse(JSON.stringify(defaultState));
			result.sizeX = getWidth();
			result.sizeY = getHeight();
			requestable.forEach(x => { let param = getParam(x); if (param) result[x] = param; });
			return result;
		};

		const GeneratorLookup = [["dots", drawDot], ["emojis", drawEmoji]];

		const getGenerator = ({ displayMode }) => {
			const foundMode = GeneratorLookup.filter(x => x[0] === displayMode).map(x => x[1]).shift();
			return (foundMode) ? foundMode : drawDot;
		};

		const loadStarts = (state, { x, y, color }) => {
			state.startX = (x) ? x : getRand(state.sizeX);
			state.startY = (y) ? y : getRand(state.sizeY);
			state.pointAttr.color = (color) ? color : getRand(360);
			return state;
		};

		const loadRandomStarts = state => loadStarts(state, { x: undefined, y: undefined, color: undefined });

		const buildSvgTag = () => {
			const result = document.createElementNS("http://www.w3.org/2000/svg", "g");
			const currState = loadRandomStarts(getState());
			[...generatePoints(currState)].map(getGenerator(currState)).forEach(x => result.appendChild(x));
			return result;
		};

		const loadNew = () => {
			const delay = Number(getParam('delay'));
			const frameCount = Number(getParam('frameCount'));
			const frameDelay = delay / frameCount;
			const svgTag = document.getElementsByTagName("svg")[0];
			for (let currFrame = 0; currFrame < frameCount; currFrame++) {
				let currG = buildSvgTag();
				let currDelay = frameDelay * (currFrame + 1);
				window.setTimeout(x => svgTag.appendChild(currG), currDelay);
				window.setTimeout(x => svgTag.removeChild(currG), (currDelay + delay));
			}
			// fix the viewport and viewbox
			window.setTimeout(loadNew, delay);
		};

		const viewHeight = getHeight();
		const viewWidth = getWidth();
		const svgTag = document.getElementsByTagName("svg")[0];
		svgTag.setAttribute('viewbox', `0 0 ${viewWidth} ${viewHeight}`);
		svgTag.setAttribute('height', viewHeight);
		svgTag.setAttribute('width', viewWidth);
		loadNew();
	</script>
</svg>