<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.0" style="background-color: black">
	<script>
		const defaultState = {
			sizeX: 0,
			sizeY: 0,
			spread: 75,
			symX: true,
			symY: true,
			pointCount: 1200,
			pointAttr: { color: 0 },
			delay: 5000,
			frameCount: 6,
			displayMode: "dots",
			pointSource: "rorschach"
		};

		const getRand = (x) => Math.floor(Math.random() * x);

		const getOffset = (state) => {
			let theta = getRand(360);
			let radius = getRand(state.spread);
			return ({x: (radius * Math.cos(theta)), y: (radius * Math.sin(theta))});
		};

		const rorschach = function* (state) {
			let currX = getRand(state.sizeX);
			let currY = getRand(state.sizeY);
			// yield up to four points on each iteration
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				if (state.symX)
					yield ({x: (state.sizeX - currX), y: currY, id: `pnt${pntNdx}symX`, ...state.pointAttr});
				if (state.symY)
					yield ({x: currX, y: (state.sizeY - currY), id: `pnt${pntNdx}symY`, ...state.pointAttr});
				if (state.symX && state.symY)
					yield ({x: (state.sizeX - currX), y: (state.sizeY - currY), id: `pnt${pntNdx}bothSym`, ...state.pointAttr});
				let mover = getOffset(state);
				currX += mover.x;
				currY += mover.y;
				if (pntNdx % 17 == 3) {
					// let the symmetry settings randomly change every 17 iterations
					//  because it increases the randomness of the output
					state.symY = Math.floor(currY % 2) == 1;
					state.symX = Math.floor(currX % 2) == 1;
				}
			}
		};

		const sinus = function* (state) {
			let currX = getRand(state.sizeX / 2);
			let currY = getRand(state.sizeY);
			const nearY = Math.min((state.sizeY - currY), currY);
			const amplitude = nearY / 2;
			const zeroX = currX;
			const zeroY = currY;
			const incX = ((state.sizeX - zeroX) / Number(state.pointCount));
			let theta = 0;
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				currY = (amplitude * Math.sin(theta)) + zeroY;
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				theta += (incX / 60);
			}
		};

		const tangent = function* (state) {
			let currX = getRand(state.sizeX / 2);
			let currY = getRand(state.sizeY);
			const amplitude = (state.sizeX - currX) / 60;
			const zeroX = currX;
			const zeroY = currY;
			const incX = ((state.sizeX - zeroX) / Number(state.pointCount));
			let theta = 0;
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				currY = (amplitude * Math.tan(theta)) + zeroY;
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				theta += (incX / 60);
			}
		};

		const sawtooth = function* (state) {
			let currX = getRand(state.sizeX / 2);
			let currY = getRand(state.sizeY);
			let diff = 0;
			const nearY = Math.min((state.sizeY - currY), currY);
			const amplitude = nearY / 2;
			const zeroX = currX;
			const zeroY = currY;
			const incX = ((state.sizeX - zeroX) / Number(state.pointCount));
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				diff = currX - zeroX;
				currY = (amplitude * (diff - Math.floor(diff))) + zeroY;
			}
		};

		const fourier = (x, n) => (4 * Math.sin(n * x)) / (Math.PI * n);

		const square = function* (state) {
			let currX = getRand(state.sizeX / 2);
			let currY = getRand(state.sizeY);
			const nearY = Math.min((state.sizeY - currY), currY);
			const amplitude = nearY / 2;
			const zeroY = currY;
			const incX = ((state.sizeX - currX) / Number(state.pointCount));
			let theta = 0;
			for (let pntNdx = 0; pntNdx < state.pointCount; pntNdx++) {
				let norm = [1, 3, 5, 7, 9, 11].reduce((acc, curr) => acc + fourier(theta, curr), 0);
				currY = (amplitude * norm) + zeroY;
				yield ({x: currX, y: currY, id: `pnt${pntNdx}`, ...state.pointAttr});
				currX += incX;
				theta += (incX / 60);
			}
		};

		const SourceLookup = [["rorschach", rorschach], ["sinus", sinus], ["tangent", tangent],
			 ["sawtooth", sawtooth], ["square", square]];

		const getPointSource = ({ pointSource }) => {
			const foundSource = SourceLookup.filter(x => x[0] === pointSource).map(x => x[1]).shift();
			return (foundSource) ? foundSource : rorschach;
		};


		const generatePoints = function* (state) {
			yield* getPointSource(state)(state);
		};

		const drawDot = ({x, y, id, color}) => {
			const result = document.createElementNS("http://www.w3.org/2000/svg", "circle");
			result.setAttribute("id", id);
			result.setAttribute("cx", `${x}`);
			result.setAttribute("cy", `${y}`);
			result.setAttribute("r", `1`);
			const currCol = `hsl(${color} 100% 50%)`;
			result.setAttribute("fill", currCol);
			result.setAttribute("stroke", currCol);
			return result;
		};

		// continguous blocks of code points that have a bunch of emojis to choose from
		const EmojiBox = [[0x2600, 0x26FF], [0x2700, 0x27BF], [0x1F600, 0x1F6D5],
			 [0x1F300, 0x1F53D], [0x1F700, 0x1F773], [0x1F900, 0x1F9FF]];

		const getEmojiCodePoint = () => {
			const [min, max] = EmojiBox[getRand(EmojiBox.length)];
			return getRand(max - min) + min;
		}

		const selectEmoji = () => String.fromCodePoint(getEmojiCodePoint());

		const drawEmoji = ({x, y, id, color}) => {
			const result = document.createElementNS("http://www.w3.org/2000/svg", "text");
			result.setAttributeNS(null, "x", x);
			result.setAttributeNS(null, "y", y);
			result.setAttribute("id", id);
			const currCol = `hsl(${color} 100% 50%)`;
			result.setAttribute("fill", currCol);
			result.setAttribute("stroke", currCol);
			result.appendChild(document.createTextNode(selectEmoji()));
			return result;
		};

		const buildParms = new URLSearchParams(window.location.search);
		const requestable = ['displayMode', 'pointCount', 'delay', 'frameCount', 'spread', 'pointSource'];

		const getParam = (attrib) => {
			const requested = buildParms.get(attrib);
			return (requested) ? requested : defaultState[attrib];
		}

		const getState = () => {
			const result = JSON.parse(JSON.stringify(defaultState));
			result.pointAttr.color = getRand(360);
			result.sizeX = window.innerWidth;
			result.sizeY = window.innerHeight;
			requestable.forEach(x => result[x] = getParam(x));
			return result;
		};

		const GeneratorLookup = [["dots", drawDot], ["emojis", drawEmoji]];

		const getGenerator = ({ displayMode }) => {
			const foundMode = GeneratorLookup.filter(x => x[0] === displayMode).map(x => x[1]).shift();
			return (foundMode) ? foundMode : drawDot;
		};

		const buildSvgTag = () => {
			const result = document.createElementNS("http://www.w3.org/2000/svg", "g");
			const currState = getState();
			[...generatePoints(currState)].map(getGenerator(currState)).forEach(x => result.appendChild(x));
			return result;
		};

		const loadNew = () => {
			const delay = Number(getParam('delay'));
			const frameCount = Number(getParam('frameCount'));
			const frameDelay = delay / frameCount;
			const svgTag = document.getElementsByTagName("svg")[0];
			for (let currFrame = 0; currFrame < frameCount; currFrame++) {
				let currG = buildSvgTag();
				let currDelay = frameDelay * (currFrame + 1);
				window.setTimeout(x => svgTag.appendChild(currG), currDelay);
				window.setTimeout(x => svgTag.removeChild(currG), (currDelay + delay));
			}
			// fix the viewport and viewbox
			window.setTimeout(loadNew, delay);
		};

		const viewHeight = (window.innerHeight * .98);
		const viewWidth = (window.innerWidth * .98);
		const svgTag = document.getElementsByTagName("svg")[0];
		svgTag.setAttribute('viewbox', `0 0 ${viewWidth} ${viewHeight}`);
		svgTag.setAttribute('height', viewHeight);
		svgTag.setAttribute('width', viewWidth);
		loadNew();
	</script>
</svg>